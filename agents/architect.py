# architect.py

from agents.agent_base import BaseAgent
import os
import json
import re

class ArchitectAgent(BaseAgent):
    def __init__(self, config, memory):
        super().__init__(config, memory)
        self.role = "System Architect"
        self.description = "Decomposes user prompt into a software plan"

    def generate_plan(self, user_prompt: str) -> dict:
        print(f"\n🧠 [{self.role}] Planning based on user prompt...")

        planning_prompt = f"""
        You are a senior software architect. A user has asked you to build the following:
        \"\"\"{user_prompt}\"\"\"

        Break this into a clear software architecture plan:
        - List major components (frontend, backend, database, etc.)
        - Recommend appropriate technologies and frameworks
        - Define core files/modules and what they will do
        - Suggest a folder structure
        - Include anything the developer needs to know before coding
        Return in JSON format with keys: components, tech_stack, files, notes.

        Important:
        - 'files' should be a list of objects, each with 'path' and 'description'.
        - Do not return the 'files' section as a dictionary.
        """

        try:
            plan_response = self.call_llm(
                prompt=planning_prompt,
                model="ollama",
                system="You are a software architect."
            )
            print("📝 Raw plan response:\n", plan_response)

            plan = self.safe_json_parse(plan_response)
            plan = self.normalize_plan(plan)
        except Exception as ollama_fail:
            print(f"⚠️ Ollama plan failed: {ollama_fail}")
            if self.config.USE_GPT4_FOR_QA:
                print("⚡ Falling back to GPT-4 for architecture...")
                plan_response = self.call_llm(
                    prompt=planning_prompt,
                    model="gpt4",
                    system="You are a software architect."
                )
                print("📝 Raw GPT-4 plan:\n", plan_response)
                plan = self.safe_json_parse(plan_response)
                plan = self.normalize_plan(plan)
            else:
                print("❌ Could not generate plan. No fallback model enabled.")
                return {}

        self.memory.save("project_plan", plan)
        print("✅ Plan successfully created and saved.")
        return plan

    def safe_json_parse(self, raw_text: str) -> dict:
        try:
            return json.loads(raw_text)
        except json.JSONDecodeError:
            pass

        json_match = re.search(r'\{.*\}', raw_text, re.DOTALL)
        if not json_match:
            raise ValueError("No JSON found in response")

        try:
            return json.loads(json_match.group(0))
        except json.JSONDecodeError as e:
            raise ValueError(f"Malformed JSON could not be recovered: {e}")

    def normalize_plan(self, plan: dict) -> dict:
        """
        Convert malformed plan['files'] formats into a list of { path, description } objects.
        """
        files = plan.get("files")
        if isinstance(files, dict):
            plan["files"] = []
            for desc, path in files.items():
                path = path.strip()
                desc = desc.strip().strip(":：").lstrip("0123456789. ").strip()
                plan["files"].append({
                    "path": path,
                    "description": desc or "No description provided."
                })

        elif isinstance(files, list):
            # Ensure each item has 'path' and 'description'
            plan["files"] = [
                f if isinstance(f, dict) and "path" in f
                else {"path": str(f), "description": "Autogenerated"}
                for f in files
            ]

        else:
            plan["files"] = []

        return plan
